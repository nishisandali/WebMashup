'use strict';

exports.call = call;
exports.apply = apply;
exports.bind = bind;
exports.not = not;
exports.truthy = truthy;
exports.falsy = falsy;
exports.is = is;
exports.isNumber = isNumber;
exports.isFinite = isFinite;
exports.isInteger = isInteger;
exports.isNatural = isNatural;
exports.isNaN = isNaN;
exports.isInfinity = isInfinity;
exports.isString = isString;
exports.isBoolean = isBoolean;
exports.isSymbol = isSymbol;
exports.isKey = isKey;
exports.isPrimitive = isPrimitive;
exports.isComplex = isComplex;
exports.isInstance = isInstance;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.isDict = isDict;
exports.isArray = isArray;
exports.isList = isList;
exports.isRegExp = isRegExp;
exports.isDate = isDate;
exports.isValidDate = isValidDate;
exports.isInvalidDate = isInvalidDate;
exports.isPromise = isPromise;
exports.isIterator = isIterator;
exports.isNil = isNil;
exports.isSomething = isSomething;
exports.isEmpty = isEmpty;
exports.testBy = testBy;
exports.test = test;
exports.onlyString = onlyString;
exports.onlyList = onlyList;
exports.onlyDict = onlyDict;
exports.toArray = toArray;
exports.each = each;
exports.fold = fold;
exports.foldRight = foldRight;
exports.map = map;
exports.flatMap = flatMap;
exports.flatMapDeep = flatMapDeep;
exports.mapFilter = mapFilter;
exports.filter = filter;
exports.reject = reject;
exports.compact = compact;
exports.find = find;
exports.findRight = findRight;
exports.findIndex = findIndex;
exports.findIndexRight = findIndexRight;
exports.indexOf = indexOf;
exports.lastIndexOf = lastIndexOf;
exports.includes = includes;
exports.procure = procure;
exports.every = every;
exports.some = some;
exports.slice = slice;
exports.append = append;
exports.prepend = prepend;
exports.remove = remove;
exports.insertAtIndex = insertAtIndex;
exports.removeAtIndex = removeAtIndex;
exports.adjoin = adjoin;
exports.toggle = toggle;
exports.concat = concat;
exports.flatten = flatten;
exports.flattenDeep = flattenDeep;
exports.head = head;
exports.tail = tail;
exports.init = init;
exports.last = last;
exports.take = take;
exports.drop = drop;
exports.reverse = reverse;
exports.sort = sort;
exports.sortBy = sortBy;
exports.intersection = intersection;
exports.keyBy = keyBy;
exports.groupBy = groupBy;
exports.uniq = uniq;
exports.uniqBy = uniqBy;
exports.partition = partition;
exports.sum = sum;
exports.sumBy = sumBy;
exports.min = min;
exports.max = max;
exports.minBy = minBy;
exports.maxBy = maxBy;
exports.findMinBy = findMinBy;
exports.findMaxBy = findMaxBy;
exports.range = range;
exports.get = get;
exports.scan = scan;
exports.getIn = getIn;
exports.getter = getter;
exports.keys = keys;
exports.values = values;
exports.eachVal = eachVal;
exports.foldVals = foldVals;
exports.mapVals = mapVals;
exports.mapKeys = mapKeys;
exports.mapValsSort = mapValsSort;
exports.pickBy = pickBy;
exports.omitBy = omitBy;
exports.pickKeys = pickKeys;
exports.omitKeys = omitKeys;
exports.findVal = findVal;
exports.findKey = findKey;
exports.invert = invert;
exports.invertBy = invertBy;
exports.size = size;
exports.vacate = vacate;
exports.add = add;
exports.sub = sub;
exports.mul = mul;
exports.div = div;
exports.rem = rem;
exports.lt = lt;
exports.gt = gt;
exports.lte = lte;
exports.gte = gte;
exports.inc = inc;
exports.dec = dec;
exports.assign = assign;
exports.id = id;
exports.di = di;
exports.val = val;
exports.noop = noop;
exports.rethrow = rethrow;
exports.maskBy = maskBy;
exports.mask = mask;
exports.validate = validate;
exports.validateEach = validateEach;
exports.validateInstance = validateInstance;
exports.show = show;
// See impl.md

// Minifiable aliases
var Object_ = Object;
var NOP = Object_.prototype;
var has = NOP.hasOwnProperty;
var Array_ = Array;
var NAP = Array_.prototype;

/**
 * Fun
 */

function call(fun) {
  return fun.call.apply(fun, arguments);
}

// Called with `this = fun` for consistency with `call` and `bind`, where it's a
// side effect of not messing with the arguments for performance reasons.
function apply(fun, args) {
  return fun.apply(fun, args);
}

// Extant transformer HoF. Most of its breed are gone. Should it go, too?
function bind(fun) {
  return fun.bind.apply(fun, arguments);
}

// Extant transformer HoF. Most of its breed are gone. Should it go, too?
function not(fun) {
  validate(fun, isFunction);
  return function not_() {
    return !fun.apply(null, arguments);
  };
}

/**
 * Bool
 */

// Could use global `Boolean` but I like symmetry in definitions
var bool = exports.bool = truthy;
function truthy(value) {
  return !!value; // eslint-disable-line no-implicit-coercion
}

var negate = exports.negate = falsy;
function falsy(value) {
  return !value;
}

function is(one, other) {
  return one === other || isNaN(one) && isNaN(other);
}

function isNumber(value) {
  return typeof value === 'number';
}

function isFinite(value) {
  return isNumber(value) && !isNaN(value) && !isInfinity(value);
}

function isInteger(value) {
  return isNumber(value) && value % 1 === 0;
}

function isNatural(value) {
  return isInteger(value) && value >= 0;
}

function isNaN(value) {
  return value !== value; // eslint-disable-line no-self-compare
}

function isInfinity(value) {
  return value === Infinity || value === -Infinity;
}

function isString(value) {
  return typeof value === 'string';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isSymbol(value) {
  return typeof value === 'symbol';
}

function isKey(value) {
  return isString(value) || isSymbol(value) || isBoolean(value) || isFinite(value);
}

function isPrimitive(value) {
  return !isComplex(value);
}

function isComplex(value) {
  return isObject(value) || isFunction(value);
}

function isInstance(value, Class) {
  return isComplex(value) && value instanceof Class;
}

function isFunction(value) {
  return typeof value === 'function';
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

function isDict(value) {
  if (!isObject(value)) return false;
  var proto = Object_.getPrototypeOf(value);
  return proto === null || proto === NOP;
}

function isArray(value) {
  return isInstance(value, Array_);
}

function isList(value) {
  return isObject(value) && (isArray(value) || isNatural(value.length) && (!isDict(value) || has.call(value, 'callee')));
}

function isRegExp(value) {
  return isInstance(value, RegExp);
}

function isDate(value) {
  return isInstance(value, Date);
}

function isValidDate(value) {
  return isDate(value) && isFinite(value.valueOf());
}

function isInvalidDate(value) {
  return isDate(value) && !isValidDate(value);
}

function isPromise(value) {
  return isComplex(value) && isFunction(value.then) && isFunction(value.catch);
}

function isIterator(value) {
  return isObject(value) && isFunction(value.next) && isFunction(value.return) && isFunction(value.throw);
}

function isNil(value) {
  return value == null;
}

function isSomething(value) {
  return value != null;
}

function isEmpty(value) {
  return !size(value);
}

function testBy(value, pattern) {
  return isFunction(pattern) ? pattern(value) : isPrimitive(pattern) ? is(value, pattern) : isRegExp(pattern) ? pattern.test(value) : isList(pattern) ? isList(value) && every(pattern, testAt, value) : isDict(pattern) ? isComplex(value) && everyVal(pattern, testAt, value) : false;
}

function testAt(pattern, key, value) {
  return testBy(value[key], pattern);
}

function test(pattern) {
  return function test_(value) {
    return testBy(value, pattern);
  };
}

/**
 * Casts
 */

function onlyString(value) {
  return isString(value) ? value : '';
}

function onlyList(value) {
  return isList(value) ? value : [];
}

function onlyDict(value) {
  return isDict(value) ? value : {};
}

function toArray(value) {
  return isArray(value) ? value : map(value, id);
}

/**
 * List
 */

function each(list, fun, a, b, c, d, e) {
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      fun(list[i], i, a, b, c, d, e);
    }
  }
}

function fold(coll, acc, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(coll)) {
    for (var i = 0; i < coll.length; i += 1) {
      acc = fun(acc, coll[i], i, a, b, c, d, e);
    }
  }
  return acc;
}

function foldRight(list, acc, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = list.length - 1; i >= 0; i -= 1) {
      acc = fun(acc, list[i], i, a, b, c, d, e);
    }
  }
  return acc;
}

function map(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  list = onlyList(list);
  var out = Array_(list.length);
  for (var i = 0; i < list.length; i += 1) {
    out[i] = fun(list[i], i, a, b, c, d, e);
  }return out;
}

function flatMap(list, fun, a, b, c, d, e) {
  return flatten(map(list, fun, a, b, c, d, e));
}

function flatMapDeep(list, fun, a, b, c, d, e) {
  return flattenDeep(map(list, fun, a, b, c, d, e));
}

function mapFilter(list, fun, a, b, c, d, e) {
  return compact(map(list, fun, a, b, c, d, e));
}

function filter(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var out = [];
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      if (fun(list[i], i, a, b, c, d, e)) out.push(list[i]);
    }
  }
  return out;
}

function reject(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return filter(list, notBy, fun, a, b, c, d, e);
}

function notBy(value, key, fun, a, b, c, d, e) {
  return !fun(value, key, a, b, c, d, e);
}

function compact(list) {
  return filter(list, id);
}

function find(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return isList(list) ? list[findIndex(list, fun, a, b, c, d, e)] : undefined;
}

function findRight(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return isList(list) ? list[findIndexRight(list, fun, a, b, c, d, e)] : undefined;
}

function findIndex(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      if (fun(list[i], i, a, b, c, d, e)) return i;
    }
  }
  return -1;
}

function findIndexRight(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = list.length; --i >= 0;) {
      if (fun(list[i], i, a, b, c, d, e)) return i;
    }
  }
  return -1;
}

function indexOf(list, value) {
  return findIndex(list, isAt, value);
}

function lastIndexOf(list, value) {
  return findIndexRight(list, isAt, value);
}

function isAt(candidate, _i, value) {
  return is(candidate, value);
}

function includes(list, value) {
  return indexOf(list, value) !== -1;
}

function procure(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      var result = fun(list[i], i, a, b, c, d, e);
      if (result) return result;
    }
  }
  return undefined;
}

function every(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      if (!fun(list[i], i, a, b, c, d, e)) return false;
    }
  }
  return true;
}

function some(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      if (fun(list[i], i, a, b, c, d, e)) return true;
    }
  }
  return false;
}

function slice(list, start, end) {
  return NAP.slice.call(onlyList(list), start, end);
}

function append(list, value) {
  return toArray(list).concat([value]);
}

function prepend(list, value) {
  return [value].concat(toArray(list));
}

function remove(list, value) {
  return removeAtIndex(list, indexOf(list, value));
}

function insertAtIndex(list, index, value) {
  validate(index, isNatural);
  list = onlyList(list);
  if (!(index <= list.length)) {
    throw Error('Index ' + index + ' out of bounds for length ' + list.length);
  }
  list = map(list, id);
  list.splice(index, 0, value);
  return list;
}

function removeAtIndex(list, index) {
  validate(index, isInteger);
  list = onlyList(list);
  if (isNatural(index) && index < list.length) {
    list = map(list, id);
    list.splice(index, 1);
  }
  return list;
}

function adjoin(list, value) {
  return includes(list, value) ? toArray(list) : append(list, value);
}

function toggle(list, value) {
  return includes(list, value) ? remove(list, value) : append(list, value);
}

// Native concat seems to perform very well in the various engines I've tested.
// The only reason we don't use this for `flatten` is the argument size limit.
function concat() {
  return NAP.concat.apply([], map(arguments, toArray));
}

// This could be made more efficient for very large and deep lists by
// precalculating the length and allocating the result all at once.
// Unfortunately this requires quite a bit of extra code and would be slower for
// relatively small arrays. It would also be faster to use native array concat,
// but I haven't found a way to use it for flattening without `.apply`, which is
// subject to the argument size limit.
function flatten(list) {
  var out = [];
  each(list, pushFlat, out);
  return out;
}

function pushFlat(value, _i, out) {
  if (isList(value)) for (var i = 0; i < value.length; i += 1) {
    out.push(value[i]);
  } else out.push(value);
}

function flattenDeep(list) {
  var out = [];
  each(list, pushFlatDeep, out);
  return out;
}

function pushFlatDeep(value, _key, out) {
  if (isList(value)) each(value, pushFlatDeep, out);else out.push(value);
}

var first = exports.first = head;
function head(list) {
  return isList(list) ? list[0] : undefined;
}

function tail(list) {
  return slice(list, 1);
}

function init(list) {
  return isList(list) ? slice(list, 0, list.length - 1) : [];
}

function last(list) {
  return isList(list) ? list[list.length - 1] : undefined;
}

function take(list, count) {
  validate(count, isNumber);
  return slice(list, 0, count);
}

function drop(list, count) {
  validate(count, isNumber);
  return slice(list, count);
}

function reverse(list) {
  list = onlyList(list);
  var len = list.length;
  var out = Array_(len);
  for (var i = len; --i >= 0;) {
    out[len - i - 1] = list[i];
  }return out;
}

function sort(list, comparator) {
  return map(list, id).sort(comparator);
}

function sortBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  return sort(list, function compareBy(left, right) {
    return sortCompare(fun(left, a, b, c, d, e), fun(right, a, b, c, d, e));
  });
}

// https://tc39.github.io/ecma262/#sec-sortcompare
function sortCompare(left, right) {
  if (left === undefined && right === undefined) return 0;
  if (left === undefined) return 1;
  if (right === undefined) return -1;
  left += ''; // eslint-disable-line no-implicit-coercion
  right += ''; // eslint-disable-line no-implicit-coercion
  if (left < right) return -1;
  if (right < left) return 1;
  return 0;
}

function intersection(left, right) {
  var out = [];
  if (isList(left) && isList(right)) {
    var lr = left.length <= right.length;
    var lesser = lr ? left : right;
    var greater = lr ? right : left;
    each(greater, intersectionAdd, out, lesser);
  }
  return out;
}

function intersectionAdd(value, _key, out, control) {
  if (includes(control, value) && !includes(out, value)) out.push(value);
}

function keyBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var out = {};
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      var value = list[i];
      var key = fun(value, i, a, b, c, d, e);
      if (isKey(key)) out[key] = value;
    }
  }
  return out;
}

function groupBy(list, fun, a, b, c, d, e) {
  var out = {};
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      var value = list[i];
      var groupKey = fun(value, i, a, b, c, d, e);
      if (isKey(groupKey)) {
        if (!has.call(out, groupKey)) out[groupKey] = [];
        out[groupKey].push(value);
      }
    }
  }
  return out;
}

function uniq(list) {
  return uniqBy(list, id);
}

function uniqBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var out = [];
  if (isList(list)) {
    var attrs = [];
    for (var i = 0; i < list.length; i += 1) {
      var value = list[i];
      var attr = fun(value, i, a, b, c, d, e);
      if (!includes(attrs, attr)) {
        attrs.push(attr);
        out.push(value);
      }
    }
  }
  return out;
}

function partition(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var accepted = [];
  var rejected = [];
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      var value = list[i];
      if (fun(value, i, a, b, c, d, e)) accepted.push(value);else rejected.push(value);
    }
  }
  return [accepted, rejected];
}

function sum(list) {
  return sumBy(list, id);
}

function sumBy(list, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var acc = 0;
  if (isList(list)) {
    for (var i = 0; i < list.length; i += 1) {
      var value = fun(list[i], i, a, b, c, d, e);
      if (isFinite(value)) acc += value;
    }
  }
  return acc;
}

function min(list) {
  return minBy(list, id);
}

function max(list) {
  return maxBy(list, id);
}

function minBy(list, fun, a, b, c, d, e) {
  return fold(list, undefined, compareNumbersBy, lt, fun, a, b, c, d, e);
}

function maxBy(list, fun, a, b, c, d, e) {
  return fold(list, undefined, compareNumbersBy, gt, fun, a, b, c, d, e);
}

function compareNumbersBy(acc, value, key, compare, fun, a, b, c, d, e) {
  value = fun(value, key, a, b, c, d, e);
  return !isFinite(value) ? acc : !isFinite(acc) || compare(value, acc) ? value : acc;
}

function findMinBy(list, fun, a, b, c, d, e) {
  return findNumBy(list, lt, fun, a, b, c, d, e);
}

function findMaxBy(list, fun, a, b, c, d, e) {
  return findNumBy(list, gt, fun, a, b, c, d, e);
}

// WTF too large
function findNumBy(list, compare, fun, a, b, c, d, e) {
  validate(compare, isFunction);
  validate(fun, isFunction);
  if (!isList(list)) return undefined;
  var winningValue = undefined;
  var winningAttr = undefined;
  for (var i = 0; i < list.length; i += 1) {
    var value = list[i];
    var attr = fun(value, i, a, b, c, d, e);
    if (isFinite(attr) && (winningAttr == null || compare(attr, winningAttr))) {
      winningValue = value;
      winningAttr = attr;
    }
  }
  return winningValue;
}

// Doesn't need validation: the Array constructor rejects NaN and negatives,
// producing a decent error message.
function range(start, end) {
  var remaining = end - start;
  var out = Array_(remaining);
  while (--remaining >= 0) {
    out[remaining] = start + remaining;
  }return out;
}

/**
 * Dict
 */

function get(value, key) {
  return value == null ? undefined : value[key];
}

function scan(value) {
  for (var i = 1; i < arguments.length; i += 1) {
    value = get(value, arguments[i]);
  }return value;
}

function getIn(value, path) {
  validate(path, isList);
  for (var i = 0; i < path.length; i += 1) {
    value = get(value, path[i]);
  }return value;
}

function getter(key) {
  validate(key, isKey);
  return function get_(value) {
    return get(value, key);
  };
}

// Like `Object.keys`, but only for non-list objects.
//
// Note: at the moment of writing, ALL fpx functions that call this function
// rely on it not working for lists. If we change this, we must add non-list
// checks there.
function keys(value) {
  return isComplex(value) && !isList(value) ? Object_.keys(value) : [];
}

// Like `Object.values`, but only for non-list objects.
function values(value) {
  var out = keys(value);
  for (var i = 0; i < out.length; i += 1) {
    out[i] = value[out[i]];
  }return out;
}

function eachVal(dict, fun, a, b, c, d, e) {
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    fun(dict[key], key, a, b, c, d, e);
  }
}

function foldVals(dict, acc, fun, a, b, c, d, e) {
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    acc = fun(acc, dict[key], key, a, b, c, d, e);
  }
  return acc;
}

function mapVals(dict, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var out = {};
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    out[key] = fun(dict[key], key, a, b, c, d, e);
  }
  return out;
}

function mapKeys(dict, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var out = {};
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    var value = dict[key];
    var newKey = fun(key, value, a, b, c, d, e);
    if (isKey(newKey)) out[newKey] = value;
  }
  return out;
}

function mapValsSort(dict, fun, a, b, c, d, e) {
  var out = keys(dict).sort();
  for (var i = -1; ++i < out.length;) {
    var key = out[i];
    out[i] = fun(dict[key], key, a, b, c, d, e);
  }
  return out;
}

function pickBy(dict, fun, a, b, c, d, e) {
  var out = {};
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    var value = dict[key];
    if (fun(value, key, a, b, c, d, e)) out[key] = value;
  }
  return out;
}

function omitBy(dict, fun, a, b, c, d, e) {
  return pickBy(dict, notBy, fun, a, b, c, d, e);
}

function pickKeys(dict, keys) {
  validateEach(keys, isKey);
  var out = {};
  if (isComplex(dict) && !isList(dict)) {
    each(keys, pickKnown, dict, out);
  }
  return out;
}

function pickKnown(key, _i, src, out) {
  if (has.call(src, key)) out[key] = src[key];
}

function omitKeys(dict, keys) {
  validateEach(keys, isKey);
  var out = assign({}, dict);
  each(keys, deleteAt, out);
  return out;
}

function deleteAt(key, _i, out) {
  delete out[key];
}

function findVal(dict, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    var value = dict[key];
    if (fun(value, key, a, b, c, d, e)) return value;
  }
  return undefined;
}

function findKey(dict, fun, a, b, c, d, e) {
  validate(fun, isFunction);
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    if (fun(dict[key], key, a, b, c, d, e)) return key;
  }
  return undefined;
}

function invert(dict) {
  return invertBy(dict, id);
}

function invertBy(dict, fun, a, b, c, d, e) {
  var out = {};
  var dictKeys = keys(dict);
  for (var i = 0; i < dictKeys.length; i += 1) {
    var key = dictKeys[i];
    var newKey = fun(dict[key], key, a, b, c, d, e);
    if (isKey(newKey)) out[newKey] = key;
  }
  return out;
}

/**
 * Coll
 */

// Only collections (lists and objects) have a size. Functions and primitives,
// including strings, are considered empty. Also, see `isEmpty`.
function size(value) {
  return isList(value) ? value.length : keys(value).length;
}

function vacate(value) {
  return size(value) ? value : undefined;
}

/**
 * Ops
 */

function add(a, b) {
  return a + b;
}
function sub(a, b) {
  return a - b;
}
function mul(a, b) {
  return a * b;
}
function div(a, b) {
  return a / b;
}
function rem(a, b) {
  return a % b;
}
function lt(a, b) {
  return a < b;
}
function gt(a, b) {
  return a > b;
}
function lte(a, b) {
  return a <= b;
}
function gte(a, b) {
  return a >= b;
}
function inc(a) {
  return a + 1;
}
function dec(a) {
  return a - 1;
}

/**
 * Mutations
 */

function assign(target) {
  validate(target, isComplex);
  each(arguments, assignTo, target);
  return target;
}

function assignTo(source, _i, target) {
  eachVal(source, setAt, target);
}

function setAt(value, key, target) {
  target[key] = value;
}

/**
 * Misc
 */

// The "pure" annotation allows UglifyJS to drop this if the result is unused.
var global = /* #__PURE__ */exports.global = Function('return this')(); // eslint-disable-line no-new-func

function id(value) {
  return value;
}

function di(_, value) {
  return value;
}

function val(value) {
  return bind(id, value);
}

function noop() {}

function rethrow(value) {
  throw value;
}

function maskBy(value, pattern) {
  return isFunction(pattern) ? pattern(value) : isPrimitive(pattern) ? pattern : isRegExp(pattern) ? pattern.test(value) : isList(pattern) ? map(pattern, maskAt, onlyList(value)) : isDict(pattern) ? mapVals(pattern, maskAt, value || {}) : undefined;
}

function maskAt(pattern, key, value) {
  return maskBy(value[key], pattern);
}

function mask(pattern) {
  return function mask_(value) {
    return maskBy(value, pattern);
  };
}

function validate(value, test) {
  if (!isFunction(test)) throw Error('Expected validator function, got ' + show(test));
  if (!test(value)) throw Error('Expected ' + show(value) + ' to satisfy test ' + show(test));
}

function validateEach(list, test) {
  validate(list, isList);
  for (var i = 0; i < list.length; i += 1) {
    if (!test(list[i])) {
      throw Error('Expected ' + show(list[i]) + ' at index ' + i + ' to satisfy test ' + show(test));
    }
  }
}

function validateInstance(value, Class) {
  if (!isInstance(value, Class)) {
    throw Error('Expected ' + show(value) + ' to be an instance of ' + show(Class));
  }
}

function show(value) {
  return isFunction(value) && value.name ? value.name : isArray(value) || isDict(value) ? JSON.stringify(value) : isString(value) ? '"' + value + '"' : String(value);
}

/**
 * Internal
 */

function everyVal(dict, fun, a, b, c, d, e) {
  for (var key in dict) {
    if (!fun(dict[key], key, a, b, c, d, e)) return false;
  }
  return true;
}