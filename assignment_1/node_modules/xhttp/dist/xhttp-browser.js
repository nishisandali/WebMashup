Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Xhttp = Xhttp;
exports.transformParams = transformParams;
exports.start = start;
exports.setCallback = setCallback;
exports.open = open;
exports.sendHeaders = sendHeaders;
exports.sendBody = sendBody;
exports.abort = abort;
exports.abortSilently = abortSilently;
exports.eventToResponse = eventToResponse;
exports.getResponseBody = getResponseBody;
exports.isJSONEncodable = isJSONEncodable;
exports.isStatusOk = isStatusOk;
exports.formdataEncode = formdataEncode;
exports.headerLinesToDict = headerLinesToDict;
/**
 * Public
 */

function Xhttp(params, fun) {
  validate(params, isDict);
  validate(fun, isFunction);

  params = transformParams(params);
  var xhr = new XMLHttpRequest();

  start(xhr, params, function onXhrDone(event) {
    var response = eventToResponse(event);
    response.body = getResponseBody(xhr);
    response.params = params;
    fun(response);
  });

  return xhr;
}

function transformParams(params) {
  validate(params, isDict);
  validate(params.url, isString);
  if (params.method) validate(params.method, isString);
  var method = (params.method || 'GET').toUpperCase();

  return patch(params, {
    rawParams: params,
    method: method,
    url: encodeUrl(params.url, method, params.body),
    headers: isDict(params.headers) ? params.headers : {},
    body: encodeBody(params.body, method, findContentType(params.headers))
  });
}

function start(xhr, params, fun) {
  validate(params, isDict);
  validate(fun, isFunction);

  if (!(xhr.readyState === xhr.UNSENT || xhr.readyState === xhr.DONE)) {
    throw Error('Request can be started only when UNSENT or DONE');
  }

  setCallback(xhr, fun);
  open(xhr, params);
  sendHeaders(xhr, params);
  sendBody(xhr, params);
}

function setCallback(xhr, fun) {
  validate(fun, isFunction);
  // Only one will be called
  xhr.onabort = xhr.onerror = xhr.onload = xhr.ontimeout = fun;
}

function open(xhr, _ref) {
  var method = _ref.method,
      url = _ref.url,
      username = _ref.username,
      password = _ref.password;

  // In some circumstances Chrome may fail to report upload progress
  // unless you access `.upload` before opening the request.
  xhr.upload; // eslint-disable-line no-unused-expressions
  xhr.open(method, url, true, username, password);
}

function sendHeaders(xhr, _ref2) {
  var headers = _ref2.headers;

  if (headers) {
    for (var key in headers) {
      var value = headers[key];
      if (key && value) xhr.setRequestHeader(key, value);
    }
  }
}

function sendBody(xhr, _ref3) {
  var body = _ref3.body;

  xhr.send(body);
}

function abort(xhr) {
  if (isObject(xhr) && isFunction(xhr.abort)) {
    xhr.abort();
  }
}

function abortSilently(xhr) {
  if (isObject(xhr) && isFunction(xhr.abort)) {
    if (xhr.onabort) xhr.onabort = null;
    xhr.abort();
  }
}

function eventToResponse(event) {
  // Get current time before spending time on other actions
  var completedAt = Date.now();
  var xhr = event.target,
      reason = event.type;

  var complete = xhr.readyState === xhr.DONE;

  return {
    xhr: xhr,
    event: event,
    complete: complete,
    completedAt: completedAt,
    reason: reason,
    status: xhr.status,
    statusText: xhr.statusText,
    ok: complete ? isStatusOk(xhr.status) : undefined,
    headers: headerLinesToDict(xhr.getAllResponseHeaders())
  };
}

function getResponseBody(xhr) {
  var type = xhr.getResponseHeader('content-type');
  return (/application\/json/.test(type) ? JSON.parse(xhr.responseText) : xhr.responseText
  );
}

/**
 * Internal
 */

function isReadOnly(method) {
  return !method || /GET|HEAD|OPTIONS/i.test(method);
}

function encodeUrl(url, method, body) {
  return isReadOnly(method) && isDict(body) ? appendQuery(url, body) : url;
}

function findContentType(headers) {
  for (var key in headers) {
    if (/content-type/i.test(key)) return headers[key];
  }
  return undefined;
}

function encodeBody(body, method, contentType) {
  return isReadOnly(method) ? undefined : /application\/json/i.test(contentType) && isJSONEncodable(body) ? JSON.stringify(body) : /application\/x-www-form-urlencoded/i.test(contentType) && isDict(body) ? formdataEncode(body) : body;
}

function isJSONEncodable(value) {
  return isDict(value) || isArray(value);
}

function isStatusOk(status) {
  return status >= 200 && status <= 299;
}

function appendQuery(url, queryDict) {
  var search = formdataEncode(queryDict);
  return !search ? url : /\?/.test(url) ? url + '&' + search : url + '?' + search;
}

function formdataEncode(dict) {
  var pairs = [];
  if (isDict(dict)) {
    for (var key in dict) {
      var value = dict[key];
      if (key && value != null && value !== '') {
        pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
      }
    }
  }
  return pairs.join('&');
}

function headerLinesToDict(headerLines) {
  var out = {};
  var lines = headerLines.split(/$/m);
  for (var i = -1; ++i < lines.length;) {
    var match = lines[i].match(/^\s*([^:]+)\s*:\s*(.+)\s*$/m);
    if (!match) continue;
    var key = match[1].toLowerCase();
    var value = match[2];
    // Overrides repeating headers instead of grouping them.
    // Unsure which behavior is more practical.
    out[key] = value;
  }
  return out;
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

function isDict(value) {
  return isObject(value) && isPlainPrototype(Object.getPrototypeOf(value));
}

function isPlainPrototype(value) {
  return value === null || value === Object.prototype;
}

function isArray(value) {
  return value instanceof Array;
}

function isString(value) {
  return typeof value === 'string';
}

function isFunction(value) {
  return typeof value === 'function';
}

function validate(value, test) {
  if (!test(value)) throw Error('Expected ' + value + ' to satisfy test ' + test.name);
}

function patch(left, right) {
  var out = {};
  if (left) for (var key in left) {
    out[key] = left[key];
  }if (right) for (var _key in right) {
    out[_key] = right[_key];
  }return out;
}